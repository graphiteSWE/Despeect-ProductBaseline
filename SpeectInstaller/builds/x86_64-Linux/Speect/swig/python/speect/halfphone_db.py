# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""Speect Plug-in for SHalfphoneDB class"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_halfphone_db')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_halfphone_db')
    _halfphone_db = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_halfphone_db', [dirname(__file__)])
        except ImportError:
            import _halfphone_db
            return _halfphone_db
        if fp is not None:
            try:
                _mod = imp.load_module('_halfphone_db', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _halfphone_db = swig_import_helper()
    del swig_import_helper
else:
    import _halfphone_db
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0


__version__ = "1.0.0"
__license__= "mit"

import speect
class SHalfphoneDB(_object):
    """

    A halfphone sized unit selection database class.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SHalfphoneDB, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SHalfphoneDB, name)
    __repr__ = _swig_repr
    __swig_setmethods__["features"] = _halfphone_db.SHalfphoneDB_features_set
    __swig_getmethods__["features"] = _halfphone_db.SHalfphoneDB_features_get
    if _newclass:
        features = _swig_property(_halfphone_db.SHalfphoneDB_features_get, _halfphone_db.SHalfphoneDB_features_set)

    def name(self):
        """

        name()

        Get the name of the database.

        :return: The database name.
        :rtype: string

        """
        return _halfphone_db.SHalfphoneDB_name(self)


    def description(self):
        """

        description()

        Get a description of the database.

        :return: The database description.
        :rtype: string

        """
        return _halfphone_db.SHalfphoneDB_description(self)


    def language(self):
        """

        language()

        Get the database language.

        :return: The database language.
        :rtype: string

        """
        return _halfphone_db.SHalfphoneDB_language(self)


    def lang_code(self):
        """

        lang_code()

        Get the database's ``ISO 639-2`` language code.

        :return: The ``ISO 639-2`` language code of the database.
        :rtype: string

        """
        return _halfphone_db.SHalfphoneDB_lang_code(self)


    def version(self):
        """

        version()

        Get the database's version.

        :return: The version of the database (major, minor).
        :rtype: tuple

        """
        return _halfphone_db.SHalfphoneDB_version(self)


    def get_units(self, unit_type, left_context=None, right_context=None, 
                  min_triphones=0, min_diphones=0):
        """
        Get a list of units (``SItem`` type units) from the halfphone database that
        conform to the given context. The current halfphone database implementation
        names unit type as follows:

            For each item in the ``Segment`` relation we have 2 halfphone units.
            For example, if the segment item is named ``dh`` then the 2 halphone
            units are named ``left-dh`` and ``right-dh``.

        The units are stored in the database with their context information. This allows
        for a type of pre-selection when requesting units. All units are in the lowest
        tier of the context information (no given context), and the upper tiers contain
        less units, but might return better contexts for concatenation. The left and 
        right contexts are named according to the ``Segment`` relation names, and *not* the
        halfphone names.


        :param unit_type: The unit type to get (halfphone unit type).
        :type unit_type: string
        :param left_context: The left context of the units to get.
        :type left_context: string
        :param right_context: The right context of the units to get.
        :type right_context: string
        :param min_triphones: The minimum number of triphone contexts required. 
                              If this number is not satisfied then diphone contexts
                              are also searched for.
        :type min_triphones: int
        :param min_diphones: The minimum number of diphone contexts required. If this
                             number is not satisfied then all units of the given unit
                             type are returned.
        :type min_diphones: int
        :return: A list of unit items (``SItem``) that satisfy the
                 given context, or ``None`` if no such units exists.
        :note: The list and the items in the list **must** be regarded as constant in
               the C sence, and **not** be modified in any way.
        """

        return _get_units(self, unit_type, 
                          left_context, right_context, 
                          min_triphones, min_diphones)


    def __init__(self):
        """

        A halfphone sized unit selection database class.

        """
        this = _halfphone_db.new_SHalfphoneDB()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _halfphone_db.delete_SHalfphoneDB
    __del__ = lambda self: None
SHalfphoneDB_swigregister = _halfphone_db.SHalfphoneDB_swigregister
SHalfphoneDB_swigregister(SHalfphoneDB)


def _get_units(arg1, unit_type, left_context, right_context, min_triphones, min_diphones):
    """_get_units(SHalfphoneDB arg1, char const * unit_type, char const * left_context, char const * right_context, uint min_triphones, uint min_diphones) -> PyObject *"""
    return _halfphone_db._get_units(arg1, unit_type, left_context, right_context, min_triphones, min_diphones)
# This file is compatible with both classic and new-style classes.


